From 98357091d2f5761f744a23ce0b9fb5e88c75f204 Mon Sep 17 00:00:00 2001
From: Noeri Huisman <mrxz@users.noreply.github.com>
Date: Tue, 16 Aug 2022 21:06:14 +0200
Subject: [PATCH 2/6] WIP it compiles!

---
 device/vr/openxr/openxr_api_wrapper.cc     | 19 +++++++++++------
 device/vr/openxr/openxr_api_wrapper.h      |  8 +++++++-
 device/vr/openxr/openxr_extension_helper.h |  8 +++++++-
 device/vr/openxr/openxr_render_loop.cc     | 24 ++++++++++++++++++++++
 device/vr/openxr/openxr_util.h             |  5 -----
 device/vr/windows/compositor_base.cc       | 13 ++++++------
 6 files changed, 58 insertions(+), 19 deletions(-)

diff --git a/device/vr/openxr/openxr_api_wrapper.cc b/device/vr/openxr/openxr_api_wrapper.cc
index 49d918b78fa4c..025b29954a2a1 100644
--- a/device/vr/openxr/openxr_api_wrapper.cc
+++ b/device/vr/openxr/openxr_api_wrapper.cc
@@ -23,7 +23,7 @@
 #include "device/vr/openxr/openxr_input_helper.h"
 #include "device/vr/openxr/openxr_util.h"
 #include "device/vr/test/test_hook.h"
-#include "gpu/GLES2/gl2extchromium.h"
+//#include "gpu/GLES2/gl2extchromium.h"
 #include "gpu/command_buffer/client/shared_image_interface.h"
 #include "gpu/command_buffer/common/shared_image_usage.h"
 #include "ui/gfx/geometry/angle_conversions.h"
@@ -101,6 +101,10 @@ std::unique_ptr<OpenXrApiWrapper> OpenXrApiWrapper::Create(
 OpenXrApiWrapper::SwapChainInfo::SwapChainInfo(ID3D11Texture2D* d3d11_texture)
     : d3d11_texture(d3d11_texture) {}
 #endif
+#ifdef XR_USE_GRAPHICS_API_OPENGL
+OpenXrApiWrapper::SwapChainInfo::SwapChainInfo(uint32_t gl_image)
+    : gl_image(gl_image) {}
+#endif
 OpenXrApiWrapper::SwapChainInfo::~SwapChainInfo() {
   // If shared images are being used, the mailbox holder should have been
   // cleared before destruction, either due to the context provider being lost
@@ -560,7 +564,7 @@ XrResult OpenXrApiWrapper::CreateSwapchain() {
   color_swapchain_images_.reserve(color_swapchain_images.size());
   for (const auto& swapchain_image : color_swapchain_images) {
     color_swapchain_images_.emplace_back(
-        SwapChainInfo{swapchain_image.texture});
+        SwapChainInfo{swapchain_image.image});
   }
 
   CreateSharedMailboxes();
@@ -703,7 +707,6 @@ void OpenXrApiWrapper::ReleaseColorSwapchainImages() {
   color_swapchain_images_.clear();
 }
 
-#ifdef XR_USE_GRAPHICS_API_D3D11
 void OpenXrApiWrapper::CreateSharedMailboxes() {
   if (!context_provider_ || !ShouldCreateSharedImages()) {
     return;
@@ -711,9 +714,12 @@ void OpenXrApiWrapper::CreateSharedMailboxes() {
 
   gpu::SharedImageInterface* shared_image_interface =
       context_provider_->SharedImageInterface();
+  (void)shared_image_interface;
 
   // Create the MailboxHolders for each texture in the swap chain
   for (SwapChainInfo& swap_chain_info : color_swapchain_images_) {
+    (void)swap_chain_info;
+#ifdef XR_USE_GRAPHICS_API_D3D11
     Microsoft::WRL::ComPtr<IDXGIResource1> dxgi_resource;
     HRESULT hr = swap_chain_info.d3d11_texture->QueryInterface(
         IID_PPV_ARGS(&dxgi_resource));
@@ -771,9 +777,9 @@ void OpenXrApiWrapper::CreateSharedMailboxes() {
         kTopLeft_GrSurfaceOrigin, kPremul_SkAlphaType, shared_image_usage);
     mailbox_holder.sync_token = shared_image_interface->GenVerifiedSyncToken();
     mailbox_holder.texture_target = GL_TEXTURE_2D;
+#endif
   }
 }
-#endif
 
 bool OpenXrApiWrapper::IsUsingSharedImages() const {
   return ((color_swapchain_images_.size() > 1) &&
@@ -1023,7 +1029,7 @@ XrResult OpenXrApiWrapper::PrepareViewConfigForRender(
   return XR_SUCCESS;
 }
 
-#ifdef XR_USE_GRAPHICS_API_D3D11
+
 XrResult OpenXrApiWrapper::EndFrame() {
   DCHECK(pending_frame_);
   DCHECK(HasBlendMode());
@@ -1076,7 +1082,6 @@ XrResult OpenXrApiWrapper::EndFrame() {
 
   return XR_SUCCESS;
 }
-#endif
 
 bool OpenXrApiWrapper::HasPendingFrame() const {
   return pending_frame_;
@@ -1256,6 +1261,7 @@ std::vector<mojom::XRInputSourceStatePtr> OpenXrApiWrapper::GetInputState(
                                       GetPredictedDisplayTime());
 }
 
+#ifdef XR_USE_GRAPHICS_API_D3D11
 XrResult OpenXrApiWrapper::GetLuid(
     const OpenXrExtensionHelper& extension_helper,
     LUID& luid) const {
@@ -1276,6 +1282,7 @@ XrResult OpenXrApiWrapper::GetLuid(
 
   return XR_SUCCESS;
 }
+#endif
 
 void OpenXrApiWrapper::EnsureEventPolling() {
   // Events are usually processed at the beginning of a frame. When frames
diff --git a/device/vr/openxr/openxr_api_wrapper.h b/device/vr/openxr/openxr_api_wrapper.h
index d1269c56d9f7a..bea2e423d6f47 100644
--- a/device/vr/openxr/openxr_api_wrapper.h
+++ b/device/vr/openxr/openxr_api_wrapper.h
@@ -78,8 +78,8 @@ class OpenXrApiWrapper {
 #ifdef XR_USE_GRAPHICS_API_D3D11
   XrResult BeginFrame(Microsoft::WRL::ComPtr<ID3D11Texture2D>& texture,
                       gpu::MailboxHolder& mailbox_holder);
-  XrResult EndFrame();
 #endif
+  XrResult EndFrame();
 
   bool HasPendingFrame() const;
   bool HasFrameState() const;
@@ -213,6 +213,9 @@ class OpenXrApiWrapper {
   struct SwapChainInfo {
 #ifdef XR_USE_GRAPHICS_API_D3D11
     explicit SwapChainInfo(ID3D11Texture2D*);
+#endif
+#ifdef XR_USE_GRAPHICS_API_OPENGL
+    explicit SwapChainInfo(uint32_t);
 #endif
     ~SwapChainInfo();
     SwapChainInfo(SwapChainInfo&&);
@@ -222,6 +225,9 @@ class OpenXrApiWrapper {
 #ifdef XR_USE_GRAPHICS_API_D3D11
     raw_ptr<ID3D11Texture2D> d3d11_texture = nullptr;
     Microsoft::WRL::ComPtr<ID3D11Fence> d3d11_fence;
+#endif
+#ifdef XR_USE_GRAPHICS_API_OPENGL
+    uint32_t gl_image; // OpenGL image handle
 #endif
     gpu::MailboxHolder mailbox_holder;
   };
diff --git a/device/vr/openxr/openxr_extension_helper.h b/device/vr/openxr/openxr_extension_helper.h
index c7673c01340cd..86600b3e432b5 100644
--- a/device/vr/openxr/openxr_extension_helper.h
+++ b/device/vr/openxr/openxr_extension_helper.h
@@ -11,7 +11,13 @@
 
 #ifdef XR_USE_GRAPHICS_API_OPENGL
 #if defined(XR_USE_PLATFORM_XLIB) || defined(XR_USE_PLATFORM_XCB)
-#include <GL/glx.h>
+//# include <GL/glx.h>
+
+#include <X11/Xlib.h>
+typedef struct __GLXcontextRec *GLXContext;
+typedef XID GLXDrawable;
+typedef struct __GLXFBConfigRec *GLXFBConfig;
+
 #endif  // (XR_USE_PLATFORM_XLIB || XR_USE_PLATFORM_XCB)
 #endif
 
diff --git a/device/vr/openxr/openxr_render_loop.cc b/device/vr/openxr/openxr_render_loop.cc
index 296fd7a568799..4f24f01ee8c6b 100644
--- a/device/vr/openxr/openxr_render_loop.cc
+++ b/device/vr/openxr/openxr_render_loop.cc
@@ -4,7 +4,9 @@
 
 #include "device/vr/openxr/openxr_render_loop.h"
 
+#ifdef XR_USE_GRAPHICS_API_D3D11
 #include <d3d11_4.h>
+#endif
 
 #include "base/callback_helpers.h"
 #include "base/containers/contains.h"
@@ -49,6 +51,7 @@ mojom::XRFrameDataPtr OpenXrRenderLoop::GetNextFrameData() {
   mojom::XRFrameDataPtr frame_data = mojom::XRFrameData::New();
   frame_data->frame_id = next_frame_id_;
 
+#ifdef XR_USE_GRAPHICS_API_D3D11
   Microsoft::WRL::ComPtr<ID3D11Texture2D> texture;
   gpu::MailboxHolder mailbox_holder;
   if (XR_FAILED(openxr_->BeginFrame(texture, mailbox_holder))) {
@@ -59,6 +62,7 @@ mojom::XRFrameDataPtr OpenXrRenderLoop::GetNextFrameData() {
   if (!mailbox_holder.mailbox.IsZero()) {
     frame_data->buffer_holder = mailbox_holder;
   }
+#endif
 
   frame_data->time_delta =
       base::Nanoseconds(openxr_->GetPredictedDisplayTime());
@@ -131,6 +135,7 @@ void OpenXrRenderLoop::StartRuntime(
   VisibilityChangedCallback on_visibility_state_changed = base::BindRepeating(
       &OpenXrRenderLoop::SetVisibilityState, weak_ptr_factory_.GetWeakPtr());
 
+#ifdef XR_USE_GRAPHICS_API_D3D11
   texture_helper_.SetUseBGRA(true);
   LUID luid;
   if (XR_FAILED(openxr_->GetLuid(extension_helper_, luid)) ||
@@ -144,6 +149,17 @@ void OpenXrRenderLoop::StartRuntime(
     ExitPresent();
     std::move(start_runtime_split_callback.second).Run(false);
   }
+#endif
+#ifdef XR_USE_GRAPHICS_API_OPENGL
+  if(XR_FAILED(openxr_->InitSession(
+          enabled_features_, extension_helper_,
+          std::move(on_session_started_callback),
+          std::move(on_session_ended_callback),
+          std::move(on_visibility_state_changed)))) {
+    ExitPresent();
+    std::move(start_runtime_split_callback.second).Run(false);
+  }
+#endif
 }
 
 void OpenXrRenderLoop::OnOpenXrSessionStarted(
@@ -155,7 +171,9 @@ void OpenXrRenderLoop::OnOpenXrSessionStarted(
     return;
   }
 
+#ifdef XR_USE_GRAPHICS_API_D3D11
   texture_helper_.SetDefaultSize(openxr_->GetSwapchainSize());
+#endif
 
   StartContextProviderIfNeeded(std::move(start_runtime_callback));
 }
@@ -165,7 +183,9 @@ void OpenXrRenderLoop::StopRuntime() {
   // first, input_helper_destructor will try to call the actual openxr runtime
   // rather than the mock in tests.
   openxr_ = nullptr;
+#ifdef XR_USE_GRAPHICS_API_D3D11
   texture_helper_.Reset();
+#endif
   context_provider_.reset();
 }
 
@@ -279,6 +299,7 @@ void OpenXrRenderLoop::OnWebXrTokenSignaled(
     return;
   }
 
+#ifdef XR_USE_GRAPHICS_API_D3D11
   Microsoft::WRL::ComPtr<ID3D11Device> d3d11_device =
       texture_helper_.GetDevice();
   Microsoft::WRL::ComPtr<ID3D11Device5> d3d11_device5;
@@ -317,6 +338,7 @@ void OpenXrRenderLoop::OnWebXrTokenSignaled(
 
   SubmitFrameWithTextureHandle(frame_index, mojo::PlatformHandle(),
                                gpu::SyncToken());
+#endif
 
   // Calling SubmitFrameWithTextureHandle can cause openxr_ and
   // context_provider_ to become nullptr in ClearPendingFrameInternal if we
@@ -326,7 +348,9 @@ void OpenXrRenderLoop::OnWebXrTokenSignaled(
     // around until the next time the texture comes up for use. To avoid needing
     // to remember the swap chain index, use frame_index %
     // color_swapchain_images_.size() to keep them separated from one another.
+#ifdef XR_USE_GRAPHICS_API_D3D11
     openxr_->StoreFence(std::move(d3d11_fence), frame_index);
+#endif
   }
   if (context_provider_) {
     gpu::gles2::GLES2Interface* gl = context_provider_->ContextGL();
diff --git a/device/vr/openxr/openxr_util.h b/device/vr/openxr/openxr_util.h
index c695ba4e67cab..cb056657c13f6 100644
--- a/device/vr/openxr/openxr_util.h
+++ b/device/vr/openxr/openxr_util.h
@@ -9,11 +9,6 @@
 #include <d3d11.h>
 #endif
 
-#ifdef XR_USE_GRAPHICS_API_OPENGL
-#if defined(XR_USE_PLATFORM_XLIB) || defined(XR_USE_PLATFORM_XCB)
-#include <GL/glx.h>
-#endif  // (XR_USE_PLATFORM_XLIB || XR_USE_PLATFORM_XCB)
-#endif
 #include <vector>
 
 #include "base/logging.h"
diff --git a/device/vr/windows/compositor_base.cc b/device/vr/windows/compositor_base.cc
index d85002797081f..3d2fd059cfebc 100644
--- a/device/vr/windows/compositor_base.cc
+++ b/device/vr/windows/compositor_base.cc
@@ -304,7 +304,7 @@ void XRCompositorCommon::StartRuntimeFinish(
       FROM_HERE, base::BindOnce(std::move(callback), true, std::move(session)));
   is_presenting_ = true;
 
-  texture_helper_.SetSourceAndOverlayVisible(webxr_visible_, overlay_visible_);
+  //texture_helper_.SetSourceAndOverlayVisible(webxr_visible_, overlay_visible_);
 }
 
 void XRCompositorCommon::ExitPresent() {
@@ -325,7 +325,7 @@ void XRCompositorCommon::ExitPresent() {
   overlay_visible_ = false;
   overlay_receiver_.reset();
 
-  texture_helper_.SetSourceAndOverlayVisible(false, false);
+  //texture_helper_.SetSourceAndOverlayVisible(false, false);
 
   // Don't call StopRuntime until this thread has finished the rest of the work.
   // This is to prevent the OpenXrApiWrapper from being deleted before its
@@ -548,7 +548,7 @@ void XRCompositorCommon::SetOverlayAndWebXRVisibility(bool overlay_visible,
   }
 
   // Update texture helper.
-  texture_helper_.SetSourceAndOverlayVisible(webxr_visible, overlay_visible);
+  //texture_helper_.SetSourceAndOverlayVisible(webxr_visible, overlay_visible);
 
   // Maybe composite and submit if we have a pending that is now valid to
   // submit.
@@ -589,10 +589,11 @@ void XRCompositorCommon::MaybeCompositeAndSubmit() {
   // requests.
   if (no_submit) {
     copy_successful = false;
-    texture_helper_.CleanupNoSubmit();
+    //texture_helper_.CleanupNoSubmit();
   } else {
-    copy_successful = texture_helper_.UpdateBackbufferSizes() &&
-                      texture_helper_.CompositeToBackBuffer();
+    //copy_successful = texture_helper_.UpdateBackbufferSizes() &&
+    //                  texture_helper_.CompositeToBackBuffer();
+    copy_successful = true;
     if (copy_successful) {
       pending_frame_->frame_ready_time_ = base::TimeTicks::Now();
       if (!SubmitCompositedFrame()) {
-- 
2.37.1

