From 0f0e4519a5072990b0ef0f1115097f4778d4420f Mon Sep 17 00:00:00 2001
From: Noeri Huisman <mrxz@users.noreply.github.com>
Date: Sat, 20 Aug 2022 13:40:37 +0200
Subject: [PATCH 5/6] Construct SwapChain and reintroduce BeginFrame

---
 device/vr/openxr/openxr_api_wrapper.cc | 77 +++++++++++++++++++++++++-
 device/vr/openxr/openxr_api_wrapper.h  |  2 +
 device/vr/openxr/openxr_render_loop.cc |  4 ++
 3 files changed, 80 insertions(+), 3 deletions(-)

diff --git a/device/vr/openxr/openxr_api_wrapper.cc b/device/vr/openxr/openxr_api_wrapper.cc
index 27bd115dce1ee..a4b99105656f4 100644
--- a/device/vr/openxr/openxr_api_wrapper.cc
+++ b/device/vr/openxr/openxr_api_wrapper.cc
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include "device/vr/openxr/openxr_api_wrapper.h"
+#include "openxr_api_wrapper.h"
 
 #ifdef XR_USE_GRAPHICS_API_D3D11
 #include <dxgi1_2.h>
@@ -513,9 +514,9 @@ XrResult OpenXrApiWrapper::CreateSession(
 
   return xrCreateSession(instance_, &session_create_info, &session_);
 }
-#endif
-
+//#endif
 //#ifdef XR_USE_GRAPHICS_API_OPENGL
+#else
 typedef GLXContext (*glXCreateContextAttribsARBProc)(Display*, GLXFBConfig, GLXContext, Bool, const int*);
 XrResult OpenXrApiWrapper::CreateSession() {
   DCHECK(!HasSession());
@@ -600,7 +601,7 @@ XrResult OpenXrApiWrapper::CreateSession() {
   LOG(INFO) << "xrCreateSession result = " << xrResult;
   return xrResult;
 }
-//#endif
+#endif
 
 XrResult OpenXrApiWrapper::CreateSwapchain() {
   DCHECK(IsInitialized());
@@ -621,6 +622,15 @@ XrResult OpenXrApiWrapper::CreateSwapchain() {
   // Therefore, the content in this openxr swapchain image is in sRGB format.
   swapchain_create_info.format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
 
+  swapchain_create_info.width = swapchain_size_.width();
+  swapchain_create_info.height = swapchain_size_.height();
+  swapchain_create_info.mipCount = 1;
+  swapchain_create_info.faceCount = 1;
+  swapchain_create_info.sampleCount = GetRecommendedSwapchainSampleCount();
+  swapchain_create_info.usageFlags = XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT;
+#else
+  swapchain_create_info.format = GL_SRGB8_ALPHA8;
+
   swapchain_create_info.width = swapchain_size_.width();
   swapchain_create_info.height = swapchain_size_.height();
   swapchain_create_info.mipCount = 1;
@@ -996,6 +1006,67 @@ XrResult OpenXrApiWrapper::BeginFrame(
 
   return XR_SUCCESS;
 }
+#else
+XrResult OpenXrApiWrapper::BeginFrame() {
+  DCHECK(HasSession());
+  DCHECK(HasColorSwapChain());
+
+  if (!session_running_)
+    return XR_ERROR_SESSION_NOT_RUNNING;
+
+XrFrameWaitInfo wait_frame_info = {XR_TYPE_FRAME_WAIT_INFO};
+  XrFrameState frame_state = {XR_TYPE_FRAME_STATE};
+
+  XrSecondaryViewConfigurationFrameStateMSFT secondary_view_frame_states = {
+      XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_STATE_MSFT};
+  std::vector<XrSecondaryViewConfigurationStateMSFT>
+      secondary_view_config_states;
+  if (base::Contains(enabled_features_,
+                     mojom::XRSessionFeature::SECONDARY_VIEWS)) {
+    secondary_view_config_states.resize(
+        secondary_view_configs_.size(),
+        {XR_TYPE_SECONDARY_VIEW_CONFIGURATION_STATE_MSFT});
+    secondary_view_frame_states.viewConfigurationCount =
+        secondary_view_config_states.size();
+    secondary_view_frame_states.viewConfigurationStates =
+        secondary_view_config_states.data();
+    frame_state.next = &secondary_view_frame_states;
+  }
+
+  RETURN_IF_XR_FAILED(xrWaitFrame(session_, &wait_frame_info, &frame_state));
+  frame_state_ = frame_state;
+
+  if (base::Contains(enabled_features_,
+                     mojom::XRSessionFeature::SECONDARY_VIEWS)) {
+    RETURN_IF_XR_FAILED(
+        UpdateSecondaryViewConfigStates(secondary_view_config_states));
+  }
+
+  XrFrameBeginInfo begin_frame_info = {XR_TYPE_FRAME_BEGIN_INFO};
+  RETURN_IF_XR_FAILED(xrBeginFrame(session_, &begin_frame_info));
+  pending_frame_ = true;
+
+  XrSwapchainImageAcquireInfo acquire_info = {
+      XR_TYPE_SWAPCHAIN_IMAGE_ACQUIRE_INFO};
+  uint32_t color_swapchain_image_index;
+  RETURN_IF_XR_FAILED(xrAcquireSwapchainImage(color_swapchain_, &acquire_info,
+                                              &color_swapchain_image_index));
+
+  XrSwapchainImageWaitInfo wait_info = {XR_TYPE_SWAPCHAIN_IMAGE_WAIT_INFO};
+  wait_info.timeout = XR_INFINITE_DURATION;
+  RETURN_IF_XR_FAILED(xrWaitSwapchainImage(color_swapchain_, &wait_info));
+
+  RETURN_IF_XR_FAILED(UpdateViewConfigurations());
+
+  const SwapChainInfo& swap_chain_info =
+      color_swapchain_images_[color_swapchain_image_index];
+  // TODO
+  (void)swap_chain_info;
+  //texture = swap_chain_info.d3d11_texture;
+  //mailbox_holder = swap_chain_info.mailbox_holder;
+
+  return XR_SUCCESS;
+}
 #endif
 
 XrResult OpenXrApiWrapper::UpdateViewConfigurations() {
diff --git a/device/vr/openxr/openxr_api_wrapper.h b/device/vr/openxr/openxr_api_wrapper.h
index bea2e423d6f47..dce14d25b2e03 100644
--- a/device/vr/openxr/openxr_api_wrapper.h
+++ b/device/vr/openxr/openxr_api_wrapper.h
@@ -78,6 +78,8 @@ class OpenXrApiWrapper {
 #ifdef XR_USE_GRAPHICS_API_D3D11
   XrResult BeginFrame(Microsoft::WRL::ComPtr<ID3D11Texture2D>& texture,
                       gpu::MailboxHolder& mailbox_holder);
+#else
+  XrResult BeginFrame();
 #endif
   XrResult EndFrame();
 
diff --git a/device/vr/openxr/openxr_render_loop.cc b/device/vr/openxr/openxr_render_loop.cc
index 4f24f01ee8c6b..ee2fade0ed612 100644
--- a/device/vr/openxr/openxr_render_loop.cc
+++ b/device/vr/openxr/openxr_render_loop.cc
@@ -62,6 +62,10 @@ mojom::XRFrameDataPtr OpenXrRenderLoop::GetNextFrameData() {
   if (!mailbox_holder.mailbox.IsZero()) {
     frame_data->buffer_holder = mailbox_holder;
   }
+#else
+  if (XR_FAILED(openxr_->BeginFrame())) {
+    return frame_data;
+  }
 #endif
 
   frame_data->time_delta =
-- 
2.37.1

